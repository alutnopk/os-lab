#ifndef __HEADERS_H
#define __HEADERS_H

#include <iostream>
#include <cstdlib>
#include <fstream>
#include <algorithm>
#include <queue>
#include <unistd.h>
#include <string>
#include <pthread.h>
#include <mutex>
#include <condition_variable>
#include <fcntl.h>
#include <cstring>
#include <cmath>
#include <sstream>
#include <time.h>
#include <random>
#include <unordered_set>

using namespace std;

#define MAX_NODES 37700
#define MAX_EDGES 289003
#define MAX_NBRS 9458
#define WALL_SIZE 69420
#define FEED_SIZE 69420
int x, y;

typedef enum ActionType
{
    POST,
    COMMENT,
    LIKE
} ActionType;

void* userSimulator(void*);
void* pushUpdate(void*);
void* readPost(void*);

// struct to store action
typedef struct Action
{
    int actionId; // we assume 0, 1, 2 are the actions
    // ActionType actionId;
    int userId;
    int senderDegree;
    int actionType;
    time_t actionTime;
} Action; 


// struct used to store the adjacency list for a node
typedef struct AdjList
{
    int current;       // node number, is -1 when uninitialized
    int orderType;
    int postNo;
    int likesNo;
    int commentsNo;
    unordered_set<int> nbrs;  // array of neighbors of current node
    int degree;
    queue <Action> wall; // queue to store action generated by myself
    queue <Action> feed; // queue to store action generated by friends
} AdjList;


// object definition to store graph in adjacency list form, along with its shortest paths from each source node
class Graph
{
    public:

    vector<AdjList> nodelist; // adjacency list
    int nodeCount;
    
    Graph()
    {
        nodeCount = MAX_NODES;
        nodelist = vector<AdjList>(MAX_NODES);
        for(int i=0; i<MAX_NODES; i++)
        {
            nodelist[i].current = -1;
            nodelist[i].orderType = -1;
            nodelist[i].postNo = 0;
            nodelist[i].likesNo = 0;
            nodelist[i].commentsNo = 0;
            nodelist[i].nbrs = unordered_set<int>(MAX_NBRS); // calculated from the graph
            nodelist[i].degree = 0;
            nodelist[i].wall = queue<Action>(); // TODO: design size
            nodelist[i].feed = queue<Action>(); // TODO: design size
        }
    }
    int init(string filepath);

    void print_graph();

    void populate_wall();
    void print_wall();
};

void Graph::populate_wall()
{
    // populate wall
    // nodelist[0].wall.push(0);
    // nodelist[0].wall.push(1);
    // nodelist[0].wall.push(2);
    // nodelist[0].wall.push(3);
}

void Graph::print_wall()
{
    // cout << nodelist[0].wall.size() << endl;
    // while(!nodelist[0].wall.empty())
    // {
    //     int x = nodelist[0].wall.front();
    // 	cout<<" "<<x;
    // 	nodelist[0].wall.pop();
    // }
}

// initializes the graph object with the textfile data
int Graph::init(string filepath)
{
    srand(time(NULL));
    fstream fs;
    // int x, y;
    fs.open(filepath, ios::in);
    if (!fs)
    {
        return -1; // error opening file
    }
    if (fs.is_open())
    {
        string line;
        getline(fs, line); // skip first line (header)
        while (getline(fs, line))
        {
            stringstream slin(line);
            string token;
            getline(slin, token, ',');
            x = stoi(token);
            getline(slin, token, ',');
            y = stoi(token);

            // update (current), orderType, nbrs and degree

            AdjList& nodex = nodelist[x];
            AdjList& nodey = nodelist[y];
            if(nodex.current == -1){ nodex.current = x; nodex.orderType = rand() % 2; }
            if(nodey.current == -1){ nodey.current = y; nodey.orderType = rand() % 2; }
            
            nodex.nbrs.insert(y); nodex.degree = nodex.nbrs.size();
            nodey.nbrs.insert(x); nodey.degree = nodey.nbrs.size();
        }
    }
    return 0; // success
}

void Graph::print_graph()
{
    // int maxnbrs = 0;
    // int idx=-1;
    for(int i=0; i<nodeCount; i++)
    {
        AdjList& inode = nodelist[i];
        if(inode.current == -1) continue;
        int k = 0;
        cout << inode.current << ": ";
        // cout << inode.orderType;
        for (auto &nbr : inode.nbrs)
        {
            cout << nbr << " ";
            k++;
        }
        // if(k>maxnbrs)
        // {
        //     maxnbrs = k; idx = inode.current;
        // }
        cout << endl;
    }
    // cout<<"max neighbor count is: "<<maxnbrs<<" at "<<idx<<endl; 
}

#endif
