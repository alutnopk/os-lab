#ifndef __HEADERS_H
#define __HEADERS_H

#include <iostream>
#include <fstream>
#include <algorithm>
#include <queue>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string>
#include <pthread.h>
#include <mutex>
#include <condition_variable>
#include <semaphore.h>
#include <fcntl.h>
#include <cstring>
#include <sstream>
#include <climits>
#include <chrono>
#include <random>

using namespace std;

#define MAX_COUNT 37701


// struct used to store the adjacency list for a node
typedef struct AdjList
{
    int current; // current node
    int neighborCount; // no. of neighbors
    vector <int> nbrs; // array of neighbors of current node
    // queue <int> wall; // queue to store action generated by myself
    // queue <int> feed; // queue to store action generated by friends 
} AdjList;

// object definition to store graph in adjacency list form, along with its shortest paths from each source node
class Graph
{
    public:
    vector <AdjList> nodelist; // adjacency list

    Graph()
    {
        for(int i=0; i<MAX_COUNT; i++) { this->nodelist[i].current = -1; this->nodelist[i].neighborCount = 0; }
    }
    int init(string filepath);

    void print_graph(string filepath, int startidx, int endidx);
    
   
    void populate_wall();
    void print_wall();
};

void Graph::populate_wall()
{
    // populate wall
    // nodelist[0].wall.push(0);
    // nodelist[0].wall.push(1);
    // nodelist[0].wall.push(2);
    // nodelist[0].wall.push(3);
}

void Graph::print_wall()
{
    // cout << nodelist[0].wall.size() << endl;
    // while(!nodelist[0].wall.empty())
    // {
    //     int x = nodelist[0].wall.front();
	// 	cout<<" "<<x;
	// 	nodelist[0].wall.pop();
	// }
}

// initializes the graph object with the textfile data
int Graph::init(string filepath)
{
    // initialize
    for(int i=0; i<MAX_COUNT; i++) { this->nodelist[i].current = -1; this->nodelist[i].neighborCount = 0; }

    fstream fs;
    int k=0;
    fs.open(filepath, ios::in); 
    if(!fs) return -1;
    if(fs.is_open())
    {
        string lin;
        int x, y;
        while(getline(fs, lin))
        {
            k++;
            if(k==1) continue; // skip first line (header)
            // read x,y from input file
            stringstream slin(lin);
            string token;
            getline(slin, token, ',');
            x = stoi(token);
            getline(slin, token, ',');
            y = stoi(token);

            int ix = nodelist[x].current, iy = nodelist[y].current;
            if(ix>=0 && iy>=0) // if both x,y are old nodes
            {
                // add y into x-list if y isn't already present
                for(int j=0; j<nodelist[x].neighborCount; j++) // iterate through neighbors of x
                    if(nodelist[x].neighborlist[j] == y) goto y_repeated; // if y already found, skip addition step

                nodelist[x].neighborlist[nodelist[x].neighborCount] = y;
                nodelist[x].neighborCount += 1;
                if(nodelist[x].neighborCount >= MAX_COUNT+1) return -1; // check if limit reached
                y_repeated:

                // add x into y-list if x isn't already present
                for(int j=0; j<nodelist[y].neighborCount; j++) // iterate through neighbors of y
                    if(nodelist[y].neighborlist[j] == x) goto x_repeated; // if x already found, skip addition step
                // else add x as neighbor
                nodelist[y].neighborlist[nodelist[iy].neighborCount] = x;
                nodelist[y].neighborCount += 1;
                if(nodelist[y].neighborCount >= MAX_COUNT+1) return -1; // check if limit reached
                x_repeated:
                ;
            }
            else if(ix>=0 && iy==-1) // x is old node, y is new
            {
                // add y to x-list
                nodelist[x].neighborlist[nodelist[x].neighborCount] = y;
                nodelist[x].neighborCount += 1;
                if(nodelist[x].neighborCount >= MAX_COUNT+1) return -1; // check if limit reached
                // init y-list
                nodelist[y].current = y;
                nodelist[y].neighborlist[0] = x;
                nodelist[y].neighborCount = 1;
                nodeCount++;
            }
            else if(ix==-1 && iy>=0) // x is new node, y is old
            {
                // add x to y-list
                nodelist[y].neighborlist[nodelist[y].neighborCount] = x;
                nodelist[y].neighborCount += 1;
                if(nodelist[y].neighborCount >= MAX_COUNT+1) return -1; // check if limit reached
                // init x-list
                nodelist[x].current = x;
                nodelist[x].neighborlist[0] = y;
                nodelist[x].neighborCount = 1;
                nodeCount++;
            }
            else // both are new nodes
            {
                // init x-list
                nodelist[x].current = x;
                nodelist[x].neighborlist[0] = y;
                nodelist[x].neighborCount = 1;
                nodeCount++;
                // init y-list
                nodelist[y].current = y;
                nodelist[y].neighborlist[0] = x;
                nodelist[y].neighborCount = 1;
                nodeCount++;
            }
        }
    }
    return 0;
}


void Graph::print_graph(string filepath, int startidx, int endidx)
{
    // // cout<<"Total Nodes: "<<nodeCount<<endl;
    // ios_base::sync_with_stdio(false);
    // ofstream outfile;
    // outfile.open(filepath, ios_base::app);
    // if(!outfile) { cerr<<"ERROR: Cannot open file."<<endl; return; }
    // for(int i=startidx; i<=endidx;)
    // {
    //     if(nodelist[i].current == -1) continue;
    //     outfile << nodelist[i].current<<"\t:\t";
    //     // cout<<nodelist[i].current<<":";
    //     for(int j=0; j<nodelist[i].neighborCount; j++) 
    //     {
    //         outfile<<nodelist[i].neighborlist[j]<< " ";
    //         // cout<<nodelist[i].neighborlist[j]<< " ";
    //     }
    //     outfile<<"\n";
    //     // cout<<endl;
    //     i++;
    // }
    // outfile<<"----------------------------------------------"<<endl;
    // outfile.close();
    // ios_base::sync_with_stdio(true);
}


#endif
