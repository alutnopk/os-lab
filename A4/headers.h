#ifndef __HEADERS_H
#define __HEADERS_H

#include <iostream>
#include <cstdlib>
#include <fstream>
#include <algorithm>
#include <queue>
#include <unistd.h>
#include <string>
#include <pthread.h>
#include <mutex>
#include <condition_variable>
#include <fcntl.h>
#include <cstring>
#include <cmath>
#include <sstream>
#include <time.h>
#include <random>
#include <unordered_set>

using namespace std;

#define MAX_COUNT 37700
#define WALL_SIZE 69420
#define FEED_SIZE 69420
int x, y;

typedef enum ActionType
{
    POST,
    COMMENT,
    LIKE
} ActionType;

// struct to store action
typedef struct Action
{
    int actionId; // we assume 0, 1, 2 are the actions
    // ActionType actionId;
    int userId;
    int senderDegree;
    int actionType;
    time_t actionTime;
} Action; 


// struct used to store the adjacency list for a node
typedef struct AdjList
{
    int current;       // node number, is -1 when uninitialized
    int orderType;
    int postNo;
    int likesNo;
    int commentsNo;
    unordered_set<int> nbrs;  // array of neighbors of current node
    int degree;
    queue <Action> wall; // queue to store action generated by myself
    queue <Action> feed; // queue to store action generated by friends
} AdjList;


// object definition to store graph in adjacency list form, along with its shortest paths from each source node
class Graph
{
    public:

    vector<AdjList> nodelist; // adjacency list
    int nodeCount;
    
    Graph()
    {
        nodeCount = MAX_COUNT;
        nodelist = vector<AdjList>(MAX_COUNT);
        for(int i=0; i<MAX_COUNT; i++)
        {
            nodelist[i].current = -1;
            nodelist[i].orderType = -1;
            nodelist[i].postNo = 0;
            nodelist[i].likesNo = 0;
            nodelist[i].commentsNo = 0;
            nodelist[i].nbrs = unordered_set<int>(MAX_COUNT);
            nodelist[i].degree = 0;
            nodelist[i].wall = queue<Action>(); // TODO: design size
            nodelist[i].feed = queue<Action>(); // TODO: design size
        }
    }
    int init(string filepath);

    void print_graph();

    void populate_wall();
    void print_wall();
};

void Graph::populate_wall()
{
    // populate wall
    // nodelist[0].wall.push(0);
    // nodelist[0].wall.push(1);
    // nodelist[0].wall.push(2);
    // nodelist[0].wall.push(3);
}

void Graph::print_wall()
{
    // cout << nodelist[0].wall.size() << endl;
    // while(!nodelist[0].wall.empty())
    // {
    //     int x = nodelist[0].wall.front();
    // 	cout<<" "<<x;
    // 	nodelist[0].wall.pop();
    // }
}

// initializes the graph object with the textfile data
int Graph::init(string filepath)
{
    srand(time(NULL));
    fstream fs;
    // int x, y;
    fs.open(filepath, ios::in);
    if (!fs)
    {
        return -1; // error opening file
    }
    if (fs.is_open())
    {
        string line;
        getline(fs, line); // skip first line (header)
        while (getline(fs, line))
        {
<<<<<<< HEAD
            // k++;
            // if(k==11) break;
=======
>>>>>>> 8941b6f05c19578da1bc6d34688316571ea32036
            stringstream slin(line);
            string token;
            getline(slin, token, ',');
            x = stoi(token);
            getline(slin, token, ',');
            y = stoi(token);

            // update (current), orderType, nbrs and degree

            AdjList& nodex = nodelist[x];
            AdjList& nodey = nodelist[y];
            if(nodex.current == -1){ nodex.current = x; nodex.orderType = rand() % 2; }
            if(nodey.current == -1){ nodey.current = y; nodey.orderType = rand() % 2; }
            
            nodex.nbrs.insert(y); nodex.degree = nodex.nbrs.size();
            nodey.nbrs.insert(x); nodey.degree = nodey.nbrs.size();
        }
    }
    return 0; // success
}

void Graph::print_graph()
{
    for(int i=0; i<nodeCount; i++)
    {
        AdjList& inode = nodelist[i];
        if(inode.current == -1) continue;
        cout << inode.current << ": ";
        // cout << inode.orderType;
        for (auto &nbr : inode.nbrs)
        {
            cout << nbr << " ";
        }
        cout << endl;
    }
}

#endif
