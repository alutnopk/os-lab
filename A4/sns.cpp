
#include "headers.h"
#include <cmath>

#define G_FEEDSIZE 694200

Graph gptr;

queue<Action> globalFeed;

pthread_cond_t cv = PTHREAD_COND_INITIALIZER;
pthread_mutex_t mutexlock = PTHREAD_MUTEX_INITIALIZER;

void *userSimulator(void *)
{

    // create file named "sns.log" and write in it using fstream
    fstream file;
    file.open("sns.log", ios::out);
    vector<Action> temp;
    // Implement userSimulator thread here
    // choose 100 random nodes from the graph (between node ids 1 and 37,700). Then for each node, generate n actions, n needs to be proportional to the log 2 (degree of the node)
    while (1)
    {
        // cout<<"userSimulator thread running in loop"<<endl;
        for (int i = 0; i < 100; i++)
        {

            int randomNo = (rand() % 37700) + 1;
            
            auto it = find_if(gptr.nodelist.begin(), gptr.nodelist.end(), [randomNo](const AdjList &obj)
                              { return obj.current == randomNo; });
            if (it != gptr.nodelist.end())
            {
                // file << "Random Node generated: " << randomNo << endl;
                int index = distance(gptr.nodelist.begin(), it);
                int n = 10 * (1 + log2(gptr.nodelist[index].nbrs.size()));
                // file << "Number of actions generated for node:"<<randomNo<<"is"<< n << endl;
                // file << "Degree of node: " << gptr.nodelist[index].nbrs.size() << endl;
                for (int j = 0; j < n; j++)
                {
                    int action = rand() % 3;

                    if (action == 0)
                    {
                        // generate post
                        Action newAct;
                        newAct.actionId = gptr.nodelist[index].postNo;
                        gptr.nodelist[index].postNo++;
                        newAct.userId = gptr.nodelist[index].current;
                        newAct.actionType = 0;
                        newAct.senderDegree = gptr.nodelist[index].nbrs.size();
                        newAct.actionTime = time(NULL);
                        gptr.nodelist[index].wall.push(newAct);
                        temp.push_back(newAct);
                        // pthread_mutex_lock(&mutexlock);
                        // while(globalFeed.size() >= G_FEEDSIZE)
                        //     pthread_cond_wait(&cv, &mutexlock);
                        // globalFeed.push(newAct);
                        // pthread_mutex_unlock(&mutexlock);
                        // file << "Post generated by " << gptr.nodelist[index].current << endl;
                        cout << "Post generated by " << gptr.nodelist[index].current << endl;
                    }
                    else if (action == 1)
                    {
                        // generate comment
                        Action newAct;
                        newAct.actionId = gptr.nodelist[index].commentsNo;
                        gptr.nodelist[index].commentsNo++;
                        newAct.userId = gptr.nodelist[index].current;
                        newAct.actionType = 1;
                        newAct.senderDegree = gptr.nodelist[index].nbrs.size();
                        newAct.actionTime = time(NULL);
                        gptr.nodelist[index].wall.push(newAct);
                        temp.push_back(newAct);
                        // pthread_mutex_lock(&mutexlock);
                        // while(globalFeed.size() == 0)
                        //     pthread_cond_wait(&cv, &mutexlock);
                        // globalFeed.push(newAct);
                        // pthread_mutex_unlock(&mutexlock);
                        // file << "Comment generated by " << gptr.nodelist[index].current << endl;
                        cout << "Comment generated by " << gptr.nodelist[index].current << endl;
                    }
                    else
                    {
                        // generate like
                        Action newAct;
                        newAct.actionId = gptr.nodelist[index].likesNo;
                        gptr.nodelist[index].likesNo++;
                        newAct.userId = gptr.nodelist[index].current;
                        newAct.actionType = 2;
                        newAct.senderDegree = gptr.nodelist[index].nbrs.size();
                        newAct.actionTime = time(NULL);
                        gptr.nodelist[index].wall.push(newAct);
                        temp.push_back(newAct);
                        // pthread_mutex_lock(&mutexlock);
                        // while(globalFeed.size() == 0)
                        //     pthread_cond_wait(&cv, &mutexlock);
                        // globalFeed.push(newAct);
                        // pthread_mutex_unlock(&mutexlock);
                        // file << "Like generated by " << gptr.nodelist[index].current << endl;
                        cout << "Like generated by " << gptr.nodelist[index].current << endl;
                    }
                }
            }
        }
        pthread_mutex_lock(&mutexlock);
        while (globalFeed.size() >= G_FEEDSIZE)
            pthread_cond_wait(&cv, &mutexlock);
        for (int i = 0; i < temp.size(); i++)
        {
            globalFeed.push(temp[i]);
        }
        pthread_mutex_unlock(&mutexlock);

        sleep(5);
    }

    return NULL;
}

void *readPost(void *)
{
    // Implement readPost thread here

    return NULL;
}

void *pushUpdate(void *)
{
    // Implement pushUpdate thread here
    return NULL;
}

void *mainThread(void *)
{

    // load the graph from the musae_git_edges.csv file
    gptr.init("musae_git_edges.csv");
    // gptr.print_graph();
    // gptr.populate_wall();
    // gptr.print_wall();

    // Create userSimulator thread
    pthread_t userThread;
    pthread_create(&userThread, NULL, userSimulator, NULL);
    // cout<<"userSimulator thread created"<<endl;

    // // Create pool of 25 pushUpdate threads
    // std::vector<pthread_t> pushThreads(25);
    // for (int i = 0; i < 25; i++) {
    //     pthread_create(&pushThreads[i], NULL, pushUpdate, NULL);
    // }

    // // Create pool of 10 readPost threads
    // std::vector<pthread_t> readThreads(10);
    // for (int i = 0; i < 10; i++) {
    //     pthread_create(&readThreads[i], NULL, readPost, NULL);
    // }

    // // Wait for all threads to finish
    pthread_join(userThread, NULL);
    // for (int i = 0; i < 25; i++) {
    //     pthread_join(pushThreads[i], NULL);
    // }

    // for (int i = 0; i < 10; i++) {
    //     pthread_join(readThreads[i], NULL);
    // }

    return NULL;
}

int main()
{

    // Create Main thread
    pthread_t mThread;
    pthread_create(&mThread, NULL, mainThread, NULL);

    // Wait for main thread to finish
    pthread_join(mThread, NULL);

    // gptr.init("musae_git_edges.csv");
    // gptr.populate_wall();
    // gptr->init("musae_git_edges.csv");
    // gptr->print_wall();
    // cout<<gptr->nodeCount<<endl;
    // cout<<gptr->nodelist[0].current;

    return 0;
}
