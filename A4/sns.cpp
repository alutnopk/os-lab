
#include "headers.h"

#define G_FEEDSIZE 694200

Graph gptr;

queue<Action> globalFeed;

pthread_cond_t cv = PTHREAD_COND_INITIALIZER;
pthread_mutex_t mutexlock = PTHREAD_MUTEX_INITIALIZER;


void* userSimulator(void*)
{
    //create file named "sns.log" and write in it using fstream
    fstream file;
    file.open("sns.log", ios::out);
    vector<Action> temp;
    // Implement userSimulator thread here
    //choose 100 random nodes from the graph (between node ids 1 and 37,700). Then for each node, generate n actions, n needs to be proportional to the log 2 (degree of the node)
    while(1)
    {
        // cout<<"userSimulator thread running in loop"<<endl;
        for (int i=0;i<100;i++)
        {
            
            int randomNo= (rand()%37700)+1;
            auto it = find_if(gptr.nodelist.begin(), gptr.nodelist.end(), [randomNo](const AdjList& obj) { return obj.current == randomNo; });
            if (it != gptr.nodelist.end())
            {
                int index = distance(gptr.nodelist.begin(), it);
                int n = 10*(1+log2(gptr.nodelist[index].nbrs.size()));
                for(int j=0;j<n;j++)
                {
                    int action = rand()%3;
                    Action newAct;             
                    if(action==0)
                    {
                        //generate post
                        newAct.actionId = gptr.nodelist[index].postNo;
                        gptr.nodelist[index].postNo++;
                        newAct.userId = gptr.nodelist[index].current;
                        newAct.actionType = 0;
                        newAct.senderDegree = gptr.nodelist[index].nbrs.size();
                        newAct.actionTime = time(NULL);
                        gptr.nodelist[index].wall.push(newAct);

                        pthread_mutex_lock(&mutexlock);
                        while(globalFeed.size() >= G_FEEDSIZE)
                            pthread_cond_wait(&cv, &mutexlock);
                        globalFeed.push(newAct);
                        pthread_mutex_unlock(&mutexlock);
                        
                        // cout<<"post generated by "<<gptr.nodelist[index].current<<endl;

                    }
                    else if(action==1)
                    {
                        //generate comment
                        Action newAct;
                        newAct.actionId = gptr.nodelist[index].commentsNo;
                        gptr.nodelist[index].commentsNo++;
                        newAct.userId = gptr.nodelist[index].current;
                        newAct.actionType = 1;
                        newAct.senderDegree = gptr.nodelist[index].nbrs.size();
                        newAct.actionTime = time(NULL);
                        gptr.nodelist[index].wall.push(newAct);

                        pthread_mutex_lock(&mutexlock);
                        while(globalFeed.size() == 0)
                            pthread_cond_wait(&cv, &mutexlock);
                        globalFeed.push(newAct);
                        pthread_mutex_unlock(&mutexlock);

                        // cout<<"comment generated by "<<gptr.nodelist[index].current<<endl;
                    }
                    else
                    {
                        //generate like
                        Action newAct;
                        newAct.actionId = gptr.nodelist[index].likesNo;
                        gptr.nodelist[index].likesNo++;
                        newAct.userId = gptr.nodelist[index].current;
                        newAct.actionType = 2;
                        newAct.senderDegree = gptr.nodelist[index].nbrs.size();
                        newAct.actionTime = time(NULL);
                        // acquire mutex lock for globalFeed
                        gptr.nodelist[index].wall.push(newAct);

                        pthread_mutex_lock(&mutexlock);
                        while(globalFeed.size() == 0)
                            pthread_cond_wait(&cv, &mutexlock);
                        globalFeed.push(newAct);
                        pthread_mutex_unlock(&mutexlock);
                        
                        // cout<<"like generated by "<<gptr.nodelist[index].current<<endl;
                    }
                }
            }
        }
        // pthread_mutex_lock(&mutexlock);
        // while (globalFeed.size() >= G_FEEDSIZE)
        //     pthread_cond_wait(&cv, &mutexlock);
        // for (int i = 0; i < temp.size(); i++)
        // {
        //     globalFeed.push(temp[i]);
        // }
        // pthread_mutex_unlock(&mutexlock);
        sleep(120);
    }

    return NULL;
}

void* readPost(void*)
{
    // Implement readPost thread here

    return NULL;
}

void* pushUpdate(void*)
{
    // Implement pushUpdate thread here
    return NULL;
}

int main()
{
    // This *is* the main thread

    //load the graph from the musae_git_edges.csv file
    gptr.init("musae_git_edges.csv");
    gptr.print_graph();
    // gptr.populate_wall();
    // gptr.print_wall();

    // Create userSimulator thread
    pthread_t userThread;
    pthread_create(&userThread, NULL, userSimulator, NULL);
    cout<<"userSimulator thread created"<<endl;
    
    // // Create pool of 25 pushUpdate threads
    // std::vector<pthread_t> pushThreads(25);
    // for (int i = 0; i < 25; i++) {
    //     pthread_create(&pushThreads[i], NULL, pushUpdate, NULL);
    // }

    // // Create pool of 10 readPost threads
    // std::vector<pthread_t> readThreads(10);
    // for (int i = 0; i < 10; i++) {
    //     pthread_create(&readThreads[i], NULL, readPost, NULL);
    // }

    // Wait for all threads to finish
    pthread_join(userThread, NULL);
    // for (int i = 0; i < 25; i++) {
    //     pthread_join(pushThreads[i], NULL);
    // }
    
    // for (int i = 0; i < 10; i++) {
    //     pthread_join(readThreads[i], NULL);
    // }

    /////////////////////////////

    // gptr.init("musae_git_edges.csv");
    // gptr.populate_wall();
    // gptr->init("musae_git_edges.csv");
    // gptr->print_wall();
    // cout<<gptr->nodeCount<<endl;
    // cout<<gptr->nodelist[0].current;

    return 0;
}